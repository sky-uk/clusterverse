---
- block:
  - name: Get snapshots info
    ec2_snapshot_info:
      aws_access_key: "{{ lookup('env','AWS_ACCESS_KEY_ID') }}"
      aws_secret_key: "{{ lookup('env','AWS_SECRET_ACCESS_KEY') }}"
      region: "{{ cluster_vars.region }}"
      filters: "{{ _snapshot_tags[0] }}"
    register: r_ebs_snapshots

  - name: Assert that snapshots exists
    assert:
      that:
        - item in _available_snapshots
      quiet: true
      fail_msg: "{{ item }}  not in available snapshots {{ _available_snapshots }}"
    loop: "{{ _configuration_snapshots }}"
    vars:
      _available_snapshots: "{{ r_ebs_snapshots.snapshots|json_query('[].tags.backup_id')|unique }}"
      _configuration_snapshots: "{{ cluster_vars[buildenv].hosttype_vars|json_query('*.auto_volumes[].snapshot_tags.*[]')|unique }}"

  - include_tasks: aws_disks.yml
    loop_control:
      loop_var: loop_instance
    loop: "{{ cluster_hosts_flat|sort(attribute='hostname') }}"
    vars:
      _available_snapshots: "{{ r_ebs_snapshots.snapshots|json_query('[].tags.backup_id')|unique }}"

  - set_fact:
      cluster_hosts_flat: "{{ cluster_hosts_flat_snapshots }}"
      
  vars:
    _snapshot_tags: "{{ cluster_vars[buildenv].hosttype_vars|json_query('*.auto_volumes[].snapshot_tags')  }}"
  when: 
    - _snapshot_tags|length > 0

- debug:
    msg: "{{ cluster_hosts_flat }}"

- meta: end_play

- name: Create AWS security group
  ec2_group:
    name: "{{ cluster_name }}-sg"
    description: "{{ cluster_name }} rules"
    region: "{{cluster_vars.region}}"
    vpc_id: "{{vpc_id}}"
    aws_access_key: "{{cluster_vars[buildenv].aws_access_key}}"
    aws_secret_key: "{{cluster_vars[buildenv].aws_secret_key}}"
    tags:
      Name: "{{ cluster_name }}-sg"
      env: "{{ buildenv }}"
    rules: "{{ cluster_vars.secgroup_new }}"
    rules_egress:
      - proto: all
        cidr_ip: 0.0.0.0/0
  register: new_aws_sg
  when: cluster_vars.secgroup_new | length > 0

- name: Create EC2 instances
  block:
    - name: Create EC2 instances
      ec2:
        aws_access_key: "{{cluster_vars[buildenv].aws_access_key}}"
        aws_secret_key: "{{cluster_vars[buildenv].aws_secret_key}}"
        region: "{{cluster_vars.region}}"
        key_name: "{{cluster_vars[buildenv].key_name}}"
        instance_type: "{{item.flavor}}"
        instance_profile_name: "{{cluster_vars.instance_profile_name  | default(omit)}}"
        image: "{{cluster_vars.image}}"
        vpc_subnet_id: "{{item.vpc_subnet_id}}"
        assign_public_ip: "{{cluster_vars.assign_public_ip}}"
        group: "{{ cluster_vars.secgroups_existing }} {%- if cluster_vars.secgroup_new | length > 0 -%} + {{ ([new_aws_sg.group_name | default()] | default())}} {%- endif -%}"
        wait: yes
        instance_tags:
          Name: "{{item.hostname}}"
          hosttype: "{{item.hosttype}}"
          env: "{{buildenv}}"
          release: "{%- if rescuing is defined and rescuing != \"false\" and instance_to_create is defined and instance_to_create == item.hostname -%}{{rescuing}}{%- elif instance_to_create is defined and instance_to_create == item.hostname -%}{{item.release}}{%- else -%}{{item.current_release}}{%- endif -%}"
          deploy_status: "{%- if rescuing is defined and rescuing != \"false\" and instance_to_create is defined and instance_to_create == item.hostname -%}old{%- elif instance_to_create is defined and instance_to_create == item.hostname -%}new{%- else -%}{{item.current_deploy_status}}{%- endif -%}"
          cluster_name: "{{cluster_name}}"
          owner: "{{ lookup('env','USER')| lower }}"
          maintenance_mode: "{%- if prometheus_set_unset_maintenance_mode|bool -%}true{%- else -%}false{%- endif -%}"
        termination_protection: "{{cluster_vars[buildenv].termination_protection}}"
        # volumes: "{{cluster_vars[buildenv].hosttype_vars[item.hosttype].auto_volumes | default([])}}"
        count_tag:
          Name: "{{item.hostname}}"
        exact_count: 1
      # with_items: "{{cluster_hosts_flat}}"
      async: 7200
      poll: 0
      register: aws_instances





# - block:

#   - name: create | Create volumes
#     ec2_vol:
#       aws_access_key: "{{ provision_aws_access_key }}"
#       aws_secret_key: "{{ provision_aws_secret_key }}"
#       security_token: "{{ provision_security_token }}"
#       profile: "{{ provision_profile }}"
#       region: "{{ provision_region }}"
#       # this option managed on ansible level on not on AWS, therefore removed  
#       # to identify this volume as created by this role - new tag will be added
#       # delete_on_termination: "{{ item.value['delete_on_termination'] }}"
#       iops: "{% if item.value['volume_type'] == 'io1' %}{{ item.value['volume_iops'] | default(omit,true) }}{% endif %}"
#       volume_size: "{{ item.value['volume_size'] }}"
#       name: "{{ provision_ec2_instance_name }}-{{ item.key }}"
#       volume_type: "{{ item.value['volume_type'] }}"
#       encrypted: "{{ item.value['encrypted'] }}"
#       zone: "{{ _ec2_vpc_subnet_facts.subnets[0].availability_zone  }}"
#       tags: |-
#         {{ item.value['tags'] | combine({ 
#           'Hostname' : provision_ec2_instance_name,
#           'Mountpoint' : item.value['mountpoint'],
#           'Type' : provision_node_type,
#           'Device' : item.key,
#           'Fstype' : item.value['fstype'],
#           'managed_by' : 'ansible'
#       }) }}
#   loop: "{{cluster_vars[buildenv].hosttype_vars[item.hosttype].auto_volumes | default([])}}"
#   async: 7200
#   poll: 0
#   changed_when: false
#   register: _volumes_data






    - name: Wait for aws instance creation to complete
      async_status:
        jid: "{{ item.ansible_job_id }}"
      register: aws_jobs
      until: aws_jobs.finished
      delay: 3
      retries: 300
      with_items: "{{aws_instances.results}}"

  #    - debug: msg={{aws_jobs.results}}

    - name: set a fact containing newly-created hosts
      set_fact:
        cluster_hosts_flat_created: "{{ aws_jobs.results | json_query(\"[?changed==`true`].item.item\") }}"
      delegate_to: localhost
      run_once: true

    - name: update release tag when run normal deploy
      ec2_tag:
        aws_access_key: "{{cluster_vars[buildenv].aws_access_key}}"
        aws_secret_key: "{{cluster_vars[buildenv].aws_secret_key}}"
        region: "{{cluster_vars.region}}"
        resource: "{{ item }}"
        tags:
          release: "{{ release_version }}"
      delegate_to: localhost
      run_once: true
      with_items: "{{ aws_jobs.results | json_query('[].tagged_instances[0].id')}}"
      when: (instance_to_create is undefined and rescuing is undefined)

    - name: force set maintenance_mode to true (when prometheus_set_unset_maintenance_mode)
      ec2_tag:
        aws_access_key: "{{cluster_vars[buildenv].aws_access_key}}"
        aws_secret_key: "{{cluster_vars[buildenv].aws_secret_key}}"
        region: "{{cluster_vars.region}}"
        resource: "{{ item }}"
        tags:
          maintenance_mode: "true"
      delegate_to: localhost
      run_once: true
      with_items: "{{ aws_jobs.results | json_query('[].tagged_instances[0].id')}}"
      when: (prometheus_set_unset_maintenance_mode is defined and prometheus_set_unset_maintenance_mode|bool)

    - name: Extract EBS volume data so we can tag the disks
      set_fact:
        ebsdata: |
          {% set res = [] -%}
          {%- for host in aws_jobs.results -%}
            {%- for devkey in host.tagged_instances[0].block_device_mapping.keys()-%}
            {% set _dummy = res.extend([{
              'hostname': host.tagged_instances[0].tags.Name,
              'ec2_id': host.tagged_instances[0].id,
              'device_name': devkey,
              'volume_id': host.tagged_instances[0].block_device_mapping[devkey].volume_id
              }]) -%}
            {%- endfor %}
          {%- endfor %}
          {{ res }}

#    - debug: msg={{ebsdata}}

    - name: set the ec2 volume name tag
      ec2_tag:
        aws_access_key: "{{cluster_vars[buildenv].aws_access_key}}"
        aws_secret_key: "{{cluster_vars[buildenv].aws_secret_key}}"
        region: "{{cluster_vars.region}}"
        resource: "{{item.volume_id}}"
        tags:
          Name: "{{ item.hostname }}--{{item.device_name | regex_replace('^.*\\/(.*)', '\\1')}}"
      with_items: "{{ebsdata}}"
